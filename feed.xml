<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title></title>
    <subtitle></subtitle>
    <link href="https://engineersbox.github.io/websitefeed.xml" rel="self"/>
    <link href="https://engineersbox.github.io/website/"/>
    <updated>2024-09-19T00:00:00Z</updated>
    <id>https://engineersbox.github.io/website</id>
    <author>
        <name>EngineersBox</name>
        <email>&lt;None&gt;</email>
    </author>
    
        
        <entry>
            <title>Transparency with binary greedy meshing</title>
            <link href="https://engineersbox.github.io/website/eleventy-base-blog/website/2024/09/19/transparency-with-binary-greedy-meshing.html"/>
            <updated>2024-09-19T00:00:00Z</updated>
            <id>https://engineersbox.github.io/website/eleventy-base-blog/website/2024/09/19/transparency-with-binary-greedy-meshing.html</id>
            <content type="html">
                <![CDATA[
                <h2 id="motivation"><a class="header-anchor" href="#motivation"></a> Motivation</h2>
<p>I am currently utilising a variant of TanTan's Binary Greedy Mesher from <a href="https://github.com/TanTanDev/binary_greedy_mesher_demo">https://github.com/TanTanDev/binary_greedy_mesher_demo</a> for an ongoing rewrite of Minecraft for the Playstation 1 (yep that one). Mine is translated into C, but is essentially a copy-and-paste of this repo's <code>greedy_mesher_optimized.rs</code>. If you would like to see my implemention in it's full janky glory, it can be found here in the <a href="https://github.com/EngineersBox/PSX-Minecraft/blob/main/src/game/world/chunk/meshing/binary_greedy_mesher.c">PSXMC repo</a>.</p>
<p>At some later stage I will add blocks that will support partial transparency in the full texture (such as glass) and blocks with opaque textures with gaps (such as the upper half of doors or pistons). This necessitates transparency support, which the old mesher I have written, has. But using this new fancy, shiny and <em>blazingly fast</em> mesher, I want to support transparency there. So, here... we... go.</p>
<h2 id="context"><a class="header-anchor" href="#context"></a> Context</h2>
<p>Creating a mask of the voxels in the scene is done on an absolute basis, i.e. whether there is or isn't a block, marked by a bit on the relevant query axis in the mask array <code>col_face_masks</code>. This is generated using the neat shifting for left/right faces in the cull loop with:</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// set if current is solid and next is air.</span>
<span class="token keyword">let</span> col <span class="token operator">=</span> axis_cols<span class="token punctuation">[</span>axis<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// sample descending axis, and set true when air meets solid</span>
col_face_masks<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> axis <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> col <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// sample ascending axis, and set true when air meets solid</span>
col_face_masks<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> axis <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> col <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The last ops ensure that only the bits on the outer faces of a sequence of 1's is set, specifically based on the shift direction. So for instance for a slice (where <code>0</code> = air and <code>1</code> = block):</p>
<table>
	<tr>
		<td>Slice</td>
		<td>Left Faces</td>
		<td>Right Faces</td>
	</tr>
	<tr>
		<td>
<pre>
00000
00110
00110
01110
01111
</pre>
		</td>
		<td>
<pre>
00000
00100
00100
01000
01000
</pre>
		</td>
		<td>
<pre>
00000
00010
00010
00010
00001
</pre>
		</td>
	</tr>
</table>
<p>Great, this then gets used to build the plane data by creating hashmap entries for the voxel data for each set bit by retrieving the y (axial-specific) value by invoking <code>u64::trailing_zeros()</code> and combining with the x,z iterator values we are traversing through.</p>
<h2 id="the-problem"><a class="header-anchor" href="#the-problem"></a> The Problem</h2>
<p>We need some way of determining that for any given set bit, there is a following bit (relative to the direction that the face was generated for, by the shift direction) that is still visible through some form of transparency.</p>
<p>More precisely, we want to be able to detect sequential bits that are pairings of solid and transparent voxels and include them both. Let's take an example where <code>0</code> = air, <code>1</code> = transparent and <code>2</code> = solid.</p>
<p>Let's suppose we have the following slice of a chunk, which covers all the cases we need to handle:</p>
<pre class="language-rust"><code class="language-rust"><span class="token number">01120</span>
<span class="token number">01010</span>
<span class="token number">02120</span>
<span class="token number">01210</span>
<span class="token number">01222</span></code></pre>
<p>Given that we have transparent voxels, we need a way to generate the following masks for the faces in each of the rows (called <code>col</code> in code but easier to understand as rows since it's a direct map to binary visually):</p>
<table>
	<tr>
		<td>Left Faces</td>
		<td>Right Faces</td>
	</tr>
	<tr>
		<td>
<pre>
01010
01010
01000
01100
01100
</pre>
		</td>
		<td>
<pre>
00010
01010
00010
00110
00001
</pre>
		</td>
	</tr>
</table>
<p>Take a minute to see why the bits that are set as they are, we need anything solid followed by a transparent voxel in the direction of the face to be included. This begs the question... why do we want this? It is because the meshing plane construction for each face considers each bit of the column independently (assuming only one bit surrounded by zeros) by invoking <code>u64::trailing_zeros</code>. However the nature of the implementation means that if there are two <em>successive</em> 1 bits then it will consider each distinctly in mesh creation, which allows us to do this transparent-solid handling in any situation.</p>
<h2 id="solution"><a class="header-anchor" href="#solution"></a> Solution</h2>
<p>Taking a step back for a second, we can see that the essence of what we are trying to do here is actually detect any voxel that isn't empty as one mask (NE) and then detect any voxel that ins't air and isn't transparent as another mask (NET), then combine them in some manner.</p>
<p>...What?</p>
<p>Let's take our previous example where <code>0</code> = air, <code>1</code> = transparent and <code>2</code> = solid.</p>
<pre class="language-rust"><code class="language-rust"><span class="token number">01120</span>
<span class="token number">01010</span>
<span class="token number">02120</span>
<span class="token number">01210</span>
<span class="token number">01222</span></code></pre>
<p>Suppose we construct two initial mappings of this slice for each the types mentioned before (NE and NET). Let's do this based on the conditionals mentioned:</p>
<table>
	<tr>
		<td>Non-Empty (NE)</td>
		<td>Non-Empty & Non-Transparent (NET)</td>
	</tr>
	<tr>
		<td>
<pre>
01110
01010
01110
01110
01111
</pre>
		</td>
		<td>
<pre>
00010
00000
01010
00100
00111
</pre>
		</td>
	</tr>
</table>
<p>In terms of implementation it looks like this:</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// solid binary for each x,y,z axis</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> axis_cols <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// solid and non-transparent binary for each x,y,z axis</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> axis_cols_opaque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// the cull mask to perform greedy slicing, based on solids on previous axis_cols</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> col_face_masks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token attribute attr-name">#[inline]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">add_voxel_to_axis_cols</span><span class="token punctuation">(</span>
	b<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>voxel<span class="token punctuation">::</span></span><span class="token class-name">BlockData</span><span class="token punctuation">,</span>
	x<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
	y<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
	z<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
	axis_cols<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">u64</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	axis_cols_opaque<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">u64</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>b<span class="token punctuation">.</span>block_type<span class="token punctuation">.</span><span class="token function">is_solid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// x,z - y axis</span>
	axis_cols<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> y <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token comment">// z,y - x axis</span>
	axis_cols<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> x <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token comment">// x,y - z axis</span>
	axis_cols<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> z <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>b<span class="token punctuation">.</span>block_type<span class="token punctuation">.</span><span class="token function">is_transparent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// x,z - y axis</span>
		axis_cols_opaque<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> y <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
		<span class="token comment">// z,y - x axis</span>
		axis_cols_opaque<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> x <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
		<span class="token comment">// x,y - z axis</span>
		axis_cols_opaque<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> z <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>We can combine these two <em>views</em> in order to get a complete understanding of the overlapping sections, which will indicate where we need to include transparent faces. This is simply a logical AND operation between the two views on a per column basis! (Call this result NETC - NET Combined)</p>
<table>
	<tr>
		<td>Non-Empty (NE)</td>
		<td>Non-Empty & Non-Transparent (NET)</td>
		<td>Non-Empty & Non-Transparent (NETC)</td>
	</tr>
	<tr>
		<td>
<pre>
01110
01010
01110
01110
01111
</pre>
		</td>
		<td>
<pre>
00010
00000
01010
00100
00111
</pre>
		</td>
		<td>
<pre>
00010
00000
01010
00100
00111
</pre>
		</td>
	</tr>
</table>
<p>Using these two tables we can simply repeat the same shifting operations for left and right face detection (left: <code>col &amp; !(col &gt;&gt; 1)</code>, right: <code>col &amp; !(col &lt;&lt; 1)</code>) for both NE and NETC (we don't care about NET since it was used to construct NETC). This provides us a with a visualisation of visible faces for both solid and transparent voxels simultaneously. Using our example, we can see that the following face mappings are generated:</p>
<table>
	<tr>
		<td>NE</td>
		<td>NETC</td>
	</tr>
	<tr>
		<td>
			<table>
				<tr>
					<td>Left Face</td>
					<td>Right Face</td>
				</tr>
				<tr>
					<td>
<pre>
01000
01000
01000
01000
01000
</pre>
				</td>
					<td>
<pre>
00010
00010
00010
00010
00001
</pre>
					</td>
				</tr>
			</table>
		</td>
		<td>
			<table>
				<tr>
					<td>Left Face</td>
					<td>Right Face</td>
				</tr>
				<tr>
					<td>
<pre>
00010
00000
01010
00100
00100
</pre>
					</td>
					<td>
<pre>
00010
00000
01010
00100
00001
</pre>
					</td>
				</tr>
			</table>
		</td>
	</tr>
</table>
<p>We are so very close to our final map of all faces with proper transparency handling. Thankfully, the last step is just as simple as the construction of NETC. We just need to apply logical OR between the left and right maps of NE and NETC (i.e. <code>NE_L | NETC_L</code> and <code>NE_R | NETC_R</code>).</p>
<table>
	<tr>
		<td>Left Face</td>
		<td>Right Face</td>
	</tr>
	<tr>
		<td>
<pre>
01010
01000
01010
01100
01100
</pre>
		</td>
		<td>
<pre>
00010
00010
01010
00110
00001
</pre>
		</td>
	</tr>
</table>
<p>This finalised result can be added as the value for the current column face mask, corresponding to the following implementation:</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// face culling</span>
<span class="token keyword">for</span> axis <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">3</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> z <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token constant">CHUNK_SIZE_P</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token constant">CHUNK_SIZE_P</span> <span class="token punctuation">{</span>
			<span class="token comment">// set if current is solid, and next is air</span>
			<span class="token keyword">let</span> col <span class="token operator">=</span> axis_cols<span class="token punctuation">[</span>axis<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token comment">// set if current is solid and not transparent and next is air</span>
			<span class="token keyword">let</span> col_opaque <span class="token operator">=</span> col <span class="token operator">&amp;</span> axis_cols_opaque<span class="token punctuation">[</span>axis<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token comment">// solid</span>
			<span class="token keyword">let</span> solid_descending <span class="token operator">=</span> col <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">let</span> solid_ascending <span class="token operator">=</span> col <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Transparent</span>
			<span class="token keyword">let</span> opaque_descending <span class="token operator">=</span> col_opaque <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col_opaque <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">let</span> opaque_ascending <span class="token operator">=</span> col_opaque <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col_opaque <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Combined solid + transparent faces</span>
			col_face_masks<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> axis <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> solid_descending <span class="token operator">|</span> opaque_descending<span class="token punctuation">;</span>
			col_face_masks<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> axis <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> solid_ascending <span class="token operator">|</span> opaque_ascending<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>B E H O L D</strong>. We have achieved greatness. Now, subsequent (unchanged) plane mesh generation loops will do all the work for us:</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// skip padded by adding 1(for x padding) and (z+1) for (z padding)</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> col <span class="token operator">=</span> col_face_masks<span class="token punctuation">[</span>axis<span class="token punctuation">]</span><span class="token punctuation">[</span>z <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// removes the right most padding value, because it's invalid</span>
col <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// removes the left most padding value, because it's invalid</span>
col <span class="token operator">&amp;=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">CHUNK_SIZE</span> <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> col <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> col<span class="token punctuation">.</span><span class="token function">trailing_zeros</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// clear least significant set bit</span>
    col <span class="token operator">&amp;=</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// get the voxel position based on axis</span>
    <span class="token keyword">let</span> voxel_pos <span class="token operator">=</span> <span class="token keyword">match</span> axis <span class="token punctuation">{</span>
        <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">=></span> <span class="token function">ivec3</span><span class="token punctuation">(</span>x <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> z <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// down,up</span>
        <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">=></span> <span class="token function">ivec3</span><span class="token punctuation">(</span>y <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> z <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> x <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// left, right</span>
        _ <span class="token operator">=></span> <span class="token function">ivec3</span><span class="token punctuation">(</span>x <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> z <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y <span class="token keyword">as</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token comment">// forward, back</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// ... snip ao ...</span>
    <span class="token keyword">let</span> current_voxel <span class="token operator">=</span> chunks_refs<span class="token punctuation">.</span><span class="token function">get_block_no_neighbour</span><span class="token punctuation">(</span>voxel_pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// let current_voxel = chunks_refs.get_block(voxel_pos);</span>
    <span class="token comment">// we can only greedy mesh same block types + same ambient occlusion</span>
    <span class="token keyword">let</span> block_hash <span class="token operator">=</span> ao_index <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>current_voxel<span class="token punctuation">.</span>block_type <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> data <span class="token operator">=</span> data<span class="token punctuation">[</span>axis<span class="token punctuation">]</span>
        <span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>block_hash<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">or_default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">or_default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">[</span>x <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u32</span> <span class="token operator">&lt;&lt;</span> z <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Note <strong>specifically</strong>, that we get the trailing zeros as the y offset for this voxel and then clear <strong>ONLY</strong> this current voxel while creating the entry. The voxel position is queried in the world and we subsequently create a hashmap entry making this possible. Simple.</p>
<h2 id="conclusion"><a class="header-anchor" href="#conclusion"></a> Conclusion</h2>
<p>Now, theres an obvious caveat to this... you need to implement your mesh generation and subsequently the rendering pipeline such that transparency ordering is respected from the Z-axis (presumably through depth testing) here in order make use of this. This will however, guarantee that the absolute minimum amount of transparent faces are constructed in the mesh.</p>
<p>This was fun. ye.</p>
<h2 id="per-face-transparency"><a class="header-anchor" href="#per-face-transparency"></a> Per-Face Transparency</h2>
<p>You could take this a step further an allow for per-face transparency controlled at a block level. To do that you refactor the definitions of <code>axis_cols</code> and <code>axis_cols_opaque</code> to be on use per-face arrays instead of per-axis:</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// solid binary for each x,y,z face</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> face_cols <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// solid and non-transparent binary for each x,y,z face</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> face_cols_opaque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>Then you change the implementation of <code>add_voxel_to_axis_cols</code> to create per-face array entries and add a bitset (<code>u8</code>) to the block definition that has each bit set for each face in order 0-5 of up, down, left, right, front, back (or whatever your coordinate space is):</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// solid binary for each x,y,z face</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> face_cols <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// solid and non-transparent binary for each x,y,z face</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> face_cols_opaque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// the cull mask to perform greedy slicing, based on solids on previous axis_cols</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> col_face_masks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0u64</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token constant">CHUNK_SIZE_P</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[inline]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">bitset_at</span><span class="token punctuation">(</span>bitset<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>
	<span class="token punctuation">(</span><span class="token punctuation">(</span>bitset <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0b1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token attribute attr-name">#[inline]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">add_voxel_to_face_cols</span><span class="token punctuation">(</span>
	b<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>voxel<span class="token punctuation">::</span></span><span class="token class-name">BlockData</span><span class="token punctuation">,</span>
	x<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
	y<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
	z<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>
	face_cols<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">u64</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	face_cols_opaque<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">u64</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>b<span class="token punctuation">.</span>block_type<span class="token punctuation">.</span><span class="token function">is_solid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// x,z - y axis</span>
	face_cols<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> y <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	face_cols<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> y <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token comment">// z,y - x axis</span>
	face_cols<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> x <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	face_cols<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> x <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token comment">// x,y - z axis</span>
	face_cols<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> z <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	face_cols<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1u64</span> <span class="token operator">&lt;&lt;</span> z <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> <span class="token keyword">u8</span> bitset <span class="token operator">=</span> b<span class="token punctuation">.</span>opaque_faces_bitset<span class="token punctuation">;</span>
	<span class="token comment">// x,z - y axis</span>
	face_cols_opaque<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token function">bitset_at</span><span class="token punctuation">(</span>bitset<span class="token punctuation">,</span> <span class="token number">0u8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> y <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	face_cols_opaque<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token function">bitset_at</span><span class="token punctuation">(</span>bitset<span class="token punctuation">,</span> <span class="token number">1u8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> y <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token comment">// z,y - x axis</span>
	face_cols_opaque<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token function">bitset_at</span><span class="token punctuation">(</span>bitset<span class="token punctuation">,</span> <span class="token number">2u8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> x <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	face_cols_opaque<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token function">bitset_at</span><span class="token punctuation">(</span>bitset<span class="token punctuation">,</span> <span class="token number">3u8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> x <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	<span class="token comment">// x,y - z axis</span>
	face_cols_opaque<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token function">bitset_at</span><span class="token punctuation">(</span>bitset<span class="token punctuation">,</span> <span class="token number">4u8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> z <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
	face_cols_opaque<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token function">bitset_at</span><span class="token punctuation">(</span>bitset<span class="token punctuation">,</span> <span class="token number">5u8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> z <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Using the new per-face column and opaque column arrays, we can do face culling on a per-face basis, which finally allows us to have full per-face control over opacity</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// face culling</span>
<span class="token keyword">for</span> axis <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">3</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> z <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token constant">CHUNK_SIZE_P</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token constant">CHUNK_SIZE_P</span> <span class="token punctuation">{</span>
			<span class="token keyword">let</span> face_pos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> axis<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">let</span> face_neg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> axis<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token comment">// set if current is solid, and next is air</span>
			<span class="token keyword">let</span> col_pos <span class="token operator">=</span> face_cols<span class="token punctuation">[</span>face_pos<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">let</span> col_neg <span class="token operator">=</span> face_cols<span class="token punctuation">[</span>face_neg<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token comment">// set if current is solid and not transparent and next is air</span>
			<span class="token keyword">let</span> col_opaque_pos <span class="token operator">=</span> col_pos <span class="token operator">&amp;</span> face_cols_opaque<span class="token punctuation">[</span>face_pos<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">let</span> col_opaque_neg <span class="token operator">=</span> col_neg <span class="token operator">&amp;</span> face_cols_opaque<span class="token punctuation">[</span>face_neg<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token comment">// solid</span>
			<span class="token keyword">let</span> solid_descending <span class="token operator">=</span> col_pos <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col_pos <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">let</span> solid_ascending <span class="token operator">=</span> col_neg <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col_neg <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Transparent</span>
			<span class="token keyword">let</span> opaque_descending <span class="token operator">=</span> col_opaque_pos <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col_opaque_pos <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">let</span> opaque_ascending <span class="token operator">=</span> col_opaque_neg <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>col_opaque_neg <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Combined solid + transparent faces</span>
			col_face_masks<span class="token punctuation">[</span>face_pos<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> solid_descending <span class="token operator">|</span> opaque_descending<span class="token punctuation">;</span>
			col_face_masks<span class="token punctuation">[</span>face_neg<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> solid_ascending <span class="token operator">|</span> opaque_ascending<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>It's definitely going to cost a bit more in terms of cycle time, but depending on the level of control you want, this gives you a very efficient way to have complete opacity control. Much faster than a non-binary meshing approach I would think.</p>

                ]]>
            </content>
        </entry>
    
</feed>